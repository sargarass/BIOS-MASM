
.code16
.section .text
.global start

.org 0

start:
#	cli
#	mov	$0x9000, %sp
#	mov	%sp, %ss
#	mov	$0xFFFE, %sp
#	sti
	lss     %cs:STKPTR, %sp

	call	scanbios
	call	stop

STKPTR: .word   0xFFFE,0x9000
	.long	0x55FFFFAA

scanbios:
	cld
	mov     $0xC000, %si
for:	mov	%si, %ds
        xorw    %si, %si # обнуление si (source index)
        xorw    %cx, %cx # обнуление cx (counter)
        cmpw    $0xAA55, %ds:0
        jnz     next
        movb    %ds:2, %ch
        xorb    %bl, %bl # обнуление bl (base reg)

chcksm:	lodsw # грузим слово в AX
	addb    %ah, %al 
	addb    %al, %bl
        decw    %cx # декрементируем ch cl, зачем cl?
	jnz     chcksm

	or      %bl, %bl
        jnz     round

	# всё хорошо
	pusha # сохраняем  ax, cx, dx, bx, sp, bp, si, di
	push    %ds
	push    %es
	push    %fs
	push    %gs

	push    %cs # улетам фиг знает куда long jump
	push    $__ret
	push    %ds
	push    $0x03
	lret
__ret:
	pop     %gs
	pop     %fs
	pop     %es
	pop     %ds
	popa
        #define ROUND_UP(x, y) (  ((x) + ((y) - 1)) & ~((y) - 1) )
round:  mov     %ds, %si
        addw    $0x7F, %si  # (((x) + ((y) - 1))
        andw    $0xFF80, %si # & ~(y - 1) округление к двум килобайтам
        jmp check
next:   mov     %ds, %si
        addw    $0x80, %si # хз пока
check:  cmp     $0xF000, %si
        jbe     for # bhi >= беззнаковое
	# всё плохо
skip:	ret


stop:   cli
	hlt
	jmp     stop



# real startup entry begins at F000:FFF0
.section .ejump
	.byte   0xEA
	.word   start
	.word	0xF000

.org    0x0E
	.word   0x99FC

.end start
